---
title: ''
output: 
  bookdown::pdf_document2:
    latex_engine: xelatex
    number_sections: yes
    toc: no
---

# Results

Some more guidelines from the School of Geosciences.

This section should summarize the findings of the research referring to
all figures, tables and statistical results (some of which may be placed
in appendices).

-   include the primary results, ordered logically - it is often useful
    to follow the same order as presented in the methods.
-   alternatively, you may find that ordering the results from the most
    important to the least important works better for your project.
-   data should only be presented in the main text once, either in
    tables or figures; if presented in figures, data can be tabulated in
    appendices and referred to at the appropriate point in the main
    text.

**Often, it is recommended that you write the results section first, so
that you can write the methods that are appropriate to describe the
results presented. Then you can write the discussion next, then the
introduction which includes the relevant literature for the scientific
story that you are telling and finally the conclusions and abstract --
this approach is called writing backwards.**

## Determination of inflammatory groups representing intratumor inflammatory status


```{r setup, include=FALSE}
librarian::shelf(
  tidyverse, magrittr, ggplot2, ggrepel, pheatmap, viridis, ggpubr, ragg,
  snakecase, glue, rstatix, gridExtra, ggpmisc, ggplotify, patchwork
)
root_dir <- "../TargetOS-Osteosarcoma/"
knitr::opts_knit$set(root.dir = root_dir)
knitr::opts_knit$set(autodep = TRUE)

setwd(root_dir)
# Load packages
source("01_script/04_pheatmap.R")
source("01_script/05_make_MDS.R")
source("01_script/09A_signature_function.R")
source("01_script/12_optimal_kcluster.R")
```

```{r signature_construction, cache = TRUE, include=FALSE}


# Load imported data
data_path <- "../TargetOS-Osteosarcoma/03_results/TARGET-OS_GDC_protein_data.tsv"
global_data <- vroom(data_path) %>%
  column_to_rownames("hgnc_symbol") %>%
  t() %>%
  as.data.frame()


# Transform data in Z-scale
global_data_scaled <- global_data %>%
  rownames_to_column(var = "sample") %>%
  dplyr::select(-sample) %>%
  scale(center = TRUE, scale = TRUE) %>%
  bind_cols("sample" = row.names(global_data)) %>%
  column_to_rownames("sample")
global_data_scaled %<>% .[, colSums(is.na(.)) < nrow(.)] # Should be obsolete

remove_genes <- remove_unknown_genes(get_list_unknown_genes = TRUE) %>%
  extract2("Hallmark_Inflammatory_Response")


# Read data and remove unknown genes
hallmark_inflammatory <- vroom("02_data/msigdb_signature/msigdb_signature.tsv") %>%
  filter(
    gs_name == "hallmark_inflammatory_response",
    !gene_symbol %in% remove_genes
  )
hallmark_inflammatory <- global_data_scaled[, hallmark_inflammatory$gene_symbol]


# Construction of groups by mean of Z-score
hallmark_mean_groups <- hallmark_inflammatory %>%
  rownames_to_column("sample") %>%
  pivot_longer(!1, names_to = "markers") %>%
  group_by(sample) %>%
  summarise(
    median = median(value),
    mean = mean(value)
  ) %>%
  mutate(group_mean = as.factor(ntile(mean, 3))) %>%
  arrange(group_mean)
# dplyr::ntile splits input vector into n even groups


# Rename numbers to Low, Medium and High group
hallmark_mean_groups %<>%
  mutate(
    group_mean = str_replace(group_mean, "1", "Low"),
    group_mean = str_replace(group_mean, "2", "Medium"),
    group_mean = str_replace(group_mean, "3", "High"),
  ) %>% write_tsv("03_results/hallmark_mean_groups.tsv")



# Compute hallmark_mean_groups for heatmap
mds_data <- hallmark_heatmap(k_cluster = 8, scale = TRUE)
hallmark_cluster <- mds_data %>%
  dplyr::select(sample, cluster) %>%
  arrange(cluster) %>%
  dplyr::rename(cluster_8 = cluster)
hallmark_mean_groups %<>% left_join(hallmark_cluster) %>% arrange(mean)


# Histogram of hallmark mean with MDS clusters
hmg_mds_8 <- ggbarplot(hallmark_mean_groups,
  x = "sample",
  y = "mean",
  xlab = "Sample",
  ylab = "Mean (Z-Score)",
  fill = "cluster_8",
  palette = "npg",
  legend.title = "MDS Cluster",
) +
  theme(
    axis.ticks = element_blank(),
    axis.text.x = element_blank()
  )
ggsave("04_figures/ggplot/hallmark_mean_vs_sample+MDS_8_clusters.png",
  dpi = "retina"
)


## Histogram of hallmark groups of inflammation ====
hmg <- ggbarplot(hallmark_mean_groups,
  x = "sample",
  y = "mean",
  xlab = "Sample",
  ylab = "Mean (Z-Score)",
  fill = "group_mean",
  palette = "npg",
  legend.title = "Group"
) +
  theme(
    axis.ticks = element_blank(),
    axis.text.x = element_blank()
  )
ggsave("04_figures/ggplot/hallmark_mean_vs_sample+group_mean.png",
  dpi = "retina"
)



### Compute kruskal test ####
stat_table <- make_mean_comparison(hallmark_mean_groups, "mean", "group_mean")

# Compute elbow, mds and heatmap
elbow_hi <- elbow_method(hallmark_inflammatory)
mds_8 <- hallmark_heatmap(k_cluster = 8, scale = TRUE, return_plot = TRUE)


# Compute heatmap
hallmark_annotation <- hallmark_mean_groups %>%
  column_to_rownames("sample") %>%
  select("Group" = "group_mean") %>%
  `levels<-`(c("Low", "Medium", "High"))

hallmark_inflammatory <- vroom("02_data/msigdb_signature/msigdb_signature.tsv") %>%
  filter(
    gs_name == "hallmark_inflammatory_response",
    !gene_symbol %in% remove_genes
  )
hallmark_inflammatory <- global_data_scaled[, hallmark_inflammatory$gene_symbol] %>%
  t()
hallmark_inflammatory <- hallmark_inflammatory[, match(
  row.names(hallmark_annotation),
  colnames(hallmark_inflammatory)
)]



### Colors for pheatmap group mean annotation ####
gm_colors <- list("Group" = c(
  "High" = ggsci::pal_npg()(3)[1],
  "Medium" = ggsci::pal_npg()(3)[2],
  "Low" = ggsci::pal_npg()(3)[3]
))

ph <- pheatmap(
  hallmark_inflammatory,
  annotation_col = hallmark_annotation,
  main = " ",
  annotation_names_col = FALSE,
  annotation_colors = gm_colors,
  labels_row = "Gene",
  angle_col = "0",
  color = magma(256),
  cluster_cols = TRUE,
  show_colnames = FALSE,
  show_rownames = FALSE,
  cluster_rows = TRUE,
  border_color = NA,
  width = 15,
  filename = glue(
    "04_figures/pheatmap/pheatmap-hallmark_group_mean_cluster_cols.png"
  )
)


ph <- as.ggplot(ph) # Transform pheatmap intp a ggplot object
# p <- ggarrange(elbow_hi, mds_8[[2]], hmg, hmg_mds_8, labels = "AUTO")
#
# suppressWarnings(print(p)) # Used to suppress ggrepel warnings
# ggarrange(ph, labels = ("E"))
patchwork <- mds_8[[2]] + elbow_hi + hmg_mds_8 + hmg + ph
layout <- "
AAABBB
CCCDDD
EEEEEE"
patchwork <- patchwork +
  plot_layout(design = layout, heights = c(1, 1, 3)) +
  plot_annotation(tag_levels = "A") &
  theme(plot.tag = element_text(face = "bold"))
```

In order to see if inflammatory groups associated to inflammation response can be obtained, first an MDS visualization of the dataset on the Hallmark Inflammatory Response signature (HIR) containing 200 genes, from MSigDB **(Fig \@ref(fig:inflammatory-plot).A)**. The 88 osteosarcoma samples are overall clustered in the middle, while other samples are scattered outwardly. The elbow method **(Fig \@ref(fig:inflammatory-plot).B)**  seems to indicate that 2 clusters seems to be the optimal number of clusters after which the wss decreases the least. Visually, 8 clusters is the minimum amount of clusters for which each point visually belongs to its nearest cluster. 
The gene *ICAM4* was notably not detected in the dataset in the TARGET-OS cohort. Thus, 199 genes from the signature were used.

However, due to the high amount of clusters and combined with a low number of samples and the heterogeneity of the samples, another method based on the intensity of the inflammation has been tried. By doing the mean of the Z-score of the hallmark inflammatory response signature, three groups describing the inflammatory status can be obtained, classified as low, medium and high groups **(Fig \@ref(fig:inflammatory-plot).C)**.

Furthermore, the resulting groups are also partially functionally relevant as they
seem to correspond fairly well to the functional groups, defined bythe  k-means
clustering based on MDS visualization **(Fig \@ref(fig:inflammatory-plot).C, D)**. Each sample is thus attributed to its inflammatory status and this group will be subsequently used for the
following results.

```{r inflammatory-plot, echo=FALSE, fig.cap="**Construction of inflammatory groups for the 88 samples in TARGET-OS dataset based on the HIR signature from MSigDB.** **A.** MDS visualization with k-means clustering of the HIR signature. **B.** Elbow graph determining the optimal number of k-clusters. **C.** Histogram of the mean of Z-score of the HIR signature, annotated with the 8 k-means clusters. **D.** Histogram of the mean of Z-score of the HIR signature, annotated with the 3 inflammatory status groups. **E.** Heatmap of the HIR signature with samples annotated to their corresponding inflammatory groups. Rows correspond to genes and columns correspond to samples. HIR = Hallmark Inflammatory Response. MDS = Multidimensional Scaling", fig.height=12, fig.width=10, dependson= "signature_construction"}

suppressWarnings(print(patchwork))
```

## Characterization of osteosarcomas associated to inflammatory status



```{r hp_osteosarcoma, include=FALSE, cache = TRUE}

removed_genes <- remove_unknown_genes()
hp_osteosarcoma <- make_signature_list(removed_genes) %>%
  extract2("Hp_Osteosarcoma") %>%
  pivot_wider() %>%
  as.data.frame() %>%
  tibble::column_to_rownames("sample")

hm_ost <- make_pheatmap(hp_osteosarcoma,
  clustering_method = "hclust",
  pheatmap_method = "unclustered_samples",
  cluster_column = FALSE,
  transpose = TRUE,
  annotation_col = hallmark_annotation,
  annotation_colors = gm_colors,
  add_filename = "hallmark_annotation",
  pheatmap_title = " ",
  width = 10,
  border_col = NA,
  show_col = FALSE,
  return_plot = TRUE
)

hm_ost_c <- make_pheatmap(hp_osteosarcoma,
  clustering_method = "hclust",
  pheatmap_method = "unclustered_samples",
  cluster_column = TRUE,
  transpose = TRUE,
  annotation_col = hallmark_annotation,
  annotation_colors = gm_colors,
  add_filename = "hallmark_annotation-clustered",
  pheatmap_title = " ",
  width = 10,
  border_col = NA,
  show_col = FALSE,
  return_plot = TRUE
)


# Plot osteosarcoma type heatmap
osteosarcoma_annotation <- get_osteosarcoma_type()[[2]] %>%
  filter(!type %in% c("TILs Markers", "Osteoclastic Markers")) %>%
  rownames_to_column("sample") %>%
  dplyr::rename("Type" = type)
osteosarcoma_type <- get_osteosarcoma_type()[[1]] %>%
  dplyr::select(osteosarcoma_annotation$sample) %>%
  rownames_to_column("sample")
osteosarcoma_type_mean_groups <-
  left_join(hallmark_mean_groups, osteosarcoma_type) %>%
  dplyr::select(sample, "cluster" = group_mean, LUM:last_col())


hallmark_cluster <- hallmark_mean_groups %>%
  select(sample, "Group" = group_mean) %>%
  column_to_rownames("sample")
hallmark_comparison <- osteosarcoma_type_mean_groups %>%
  select(sample, LUM:last_col()) %>%
  column_to_rownames("sample")
osteosarcoma_annotation <-
  column_to_rownames(osteosarcoma_annotation, "sample")

hm_os_type_mean <- make_pheatmap(
  osteosarcoma_type_mean_groups,
  clustering_method = "manual",
  pheatmap_method = "unclustered_genes",
  annotation_row = osteosarcoma_annotation,
  pheatmap_title = " ",
  col_order = c("Low", "Medium", "High"),
  transpose = TRUE,
  add_filename = "order",
  show_col = FALSE,
  return_plot = TRUE
)

hm_os_type <- make_pheatmap(osteosarcoma_type,
  clustering_method = "hclust",
  pheatmap_method = "unclustered_samples",
  annotation_col = hallmark_cluster,
  annotation_row = osteosarcoma_annotation,
  annotation_colors = gm_colors,
  pheatmap_title = " ",
  cluster_column = TRUE,
  cluster_rows = TRUE,
  transpose = TRUE,
  show_col = FALSE,
  add_filename = "hallmark_annotation-cluster",
  width = 10,
  border_col = NA,
  return_plot = TRUE
)



## Violin plot for proliferation markers ====
proliferation <- get_osteosarcoma_type()[[2]] %>%
  filter(type == "Proliferation Markers") %>%
  rownames_to_column("markers") %>%
  rename("Type" = type)
proliferation_data <- get_osteosarcoma_type()[[1]] %>%
  select(proliferation$markers) %>%
  rownames_to_column("sample")
proliferation_group <-
  left_join(hallmark_mean_groups, proliferation_data) %>%
  rename(Group = "group_mean")

prolif_tidy <- proliferation_group %>%
  pivot_longer(proliferation$markers, "markers")



stat_prolif_1 <- make_mean_comparison(proliferation_group, "PCNA", "Group", return_table = TRUE)
stat_prolif_2 <- make_mean_comparison(proliferation_group, "MKI67", "Group")
stat_prolif_3 <- make_mean_comparison(proliferation_group, "TOP2A", "Group")
remove(markers)
stat_prolif <-
  prolif_tidy %>%
  group_by(markers) %>%
  dunn_test(value ~ Group) %>%
  add_y_position() %>%
  mutate(p.adj = insight::format_p(p.adj)) %>%
  filter(p.adj.signif == "*")

stat_kruskal <-
  prolif_tidy %>%
  group_by(markers) %>%
  kruskal_test(value ~ Group) %>%
  mutate(p = insight::format_p(p))

prov <- ggviolin(
  prolif_tidy,
  "Group",
  "value",
  fill = "Group",
  add = "mean_sd",
  facet.by = "markers",
  palette = gm_colors[[1]],
  order = c("Low", "Medium", "High"),
  subtitle = glue("Kruskal-Wallis, {stat_kruskal$p}"),
  ylab = "TPM"
) +
  stat_pvalue_manual(stat_prolif,
    label = "p.adj",
    step.increase = 0.1,
  )
```

```{r osteosarcoma-plot, echo = FALSE, dependson="hp_osteosarcoma", fig.height=14, fig.width=12, fig.cap="**Displays of various osteosarcoma related genes with samples annotated to their respective inflammatory groups.** Values are Z-scaled for heatmaps. \\newline{}(A) Heatmap *Hp Osteosarcoma* signature with unclustered samples. \\newline{}(B) Heatmap of *Hp Osteosarcoma* with clustered samples. \\newline{}(C) Heatmap of osteosarcoma type markers. \\newline{}(D) Violin plot of proliferation markers associated with their inflammatory group. "}

# Use as.ggplot() from ggplotify to turn pheatmap into ggplot
hm_ost %<>% as.ggplot()
hm_ost_c %<>% as.ggplot()
hm_os_type %<>% as.ggplot()
# pho <- ggarrange(hm_ost, hm_ost_c, hm_os_type, prov,
#                  labels = "AUTO", common.legend = TRUE
# )
#
# suppressWarnings(print(pho))

pho <- hm_ost + hm_ost_c + hm_os_type + prov
layout <- "
AAABBB
CCCCCC
DDDDDD"
pho <- pho +
  plot_layout(design = layout, heights = c(2, 2, 2, 1)) +
  plot_annotation(tag_levels = "A") &
  theme(plot.tag = element_text(face = "bold"))
suppressWarnings(print(pho))
```

In order to characterize osteosarcomas, the *Hp Osteosarcoma* gene
signature from MSigDB was used to see whether the inflammatory groups
can be related to gene expression from this signature. Visually, the
heatmap representing the gene signature, annotated with the inflammatory
groups, does seem to indicate that the samples express different genes
between Low, Medium and High inflammation group **(Figure**
\@ref(fig:osteosarcoma-plot)**A)**. However, the dendrogram clustering
the samples indicates that the gene signature does not cluster well with
the inflammatory annotations **(Figure**
\@ref(fig:osteosarcoma-plot)**B)**. However, despite high heterogeneity
between samples and inflammatory status, there seems to be an overall
distinct expression of genes in each inflammatory group.

To further characterize subtypes of osteosarcomas, comparison of the
expression of specific osteosarcoma markers relating to osteoblastic,
chondroblastic, fibroblastic markers has also been done, through a
heatmap representation. Hierarchical clustering of the samples does not
appear to be associated with corresponding inflammatory status. However
it does reveal that there are groups of osteoblastic, chondroblastic and
fibroblastic osteosarcomas which is expected (**Figure**
\@ref(fig:osteosarcoma-plot)**C**).

To assess the proliferation status of the samples related to the
inflammation status, the mean of three markers of proliferation (MKI67,
PCNA, TOP2A) have been compared, along with the mean of the three
individual markers (**Figure** \@ref(fig:osteosarcoma-plot)**D**).
Statistical Kruskal-Wallis testing is significant (*P* = 0.00968) and
post-hoc Dunn analysis reveals that the mean of the proliferation
markers between low and high group is significantly different (*P* =
0.016). The data suggests that proliferation is hindered when
inflammatory status is high in the osteosarcoma samples.

## Characterization of intra-tumor inflammation associated to inflammatory status

### General relationship of inflammatory status with immune response

#### Relationship with ESTIMATE and inflammatory signatures

Using the ESTIMATE algorithm, an immune score has been calculated for
each sample which reflects the immune infiltration in a given tumor
sample. The violin plot represents the values obtained for each
inflammatory group **(Figure** \@ref(fig:estimate-violin)**)**. Because
the data is normally distributed and has homoscedasticity, ANOVA has
been performed (*P* = 0.002) followed by Tukey's test, revealing that
there is a statistically significant difference between Low and High
group (*P* = 0.002), but not for the other conditions.

```{r estimate, include=FALSE, dependson="signature_construction"}

# For estimate_data, variable is distributed normally and has homoscedasticity
# Therefore we compute anova and tukey.
#
# add_xy_position() adds xmin and xmax in order to place the brackets, but those
# do NOT correspond to the appropriate groups in violin plot. Instead, use
# add_y_position() and xmin and xmax is referred to group1 and group2 by default
# by stat_pvalue_manual()


estimate_data <- vroom("03_results/estimate/estimate_score.tsv") %>%
  select(sample, immune) %>%
  left_join(rownames_to_column(hallmark_annotation, "sample"))

stat_tukey <-
  make_mean_comparison(estimate_data, "immune", "Group", return_tukey = TRUE) %>%
  add_y_position() %>%
  mutate(p.adj = insight::format_p(.$p.adj))
# Note that this is not relative to the groups, thus any shuffling can break the order.

ve <-
  ggviolin(
    estimate_data,
    "Group",
    "immune",
    ylab = "Immune Score",
    fill = "Group",
    add = "mean_sd",
    order = c("Low", "Medium", "High")
  ) +
  stat_compare_means(method = "anova") +
  stat_pvalue_manual(stat_tukey,
    label = "p.adj",
    step.increase = 0.1,
  )

vep <- ggarrange(ve)
```

```{r estimate-violin, fig.cap="**Violin plot of ESTIMATE score for each inflammatory group.** ANOVA was performed followed by Tukey's post-hoc analysis. P $\\leq$ 0.05 is considered statistically significant."}

suppressWarnings(print(vep))
```

#### Immune abundance by immune deconvolution algorithm

Immune cell abundance can be determined by various immune deconvolution algorithm on TPM normalized bulk-RNASeq. Here,
MCP-counter, CIBERSORTx and xCell have been tried. In MCP-counter, the mean(sd) of Z-score reflecting the abundances of neutrophils is statistically different between all groups, it is increased when the inflammation status gets higher **(Fig. \@ref(fig:immune-plot)A)**

```{r mcp_counter, cache=TRUE, include=FALSE, dependson= "signature_construction"}

if (!require("MCPcounter", quietly = TRUE)) {
  remotes::install_github("ebecht/MCPcounter", ref = "master", subdir = "Source")
}

librarian::shelf(
  tidyverse,
  magrittr,
  MCPcounter,
  ggplot2,
  ggpubr,
  ggnewscale,
  glue,
  vroom
)


hallmark <- vroom("03_results/hallmark_mean_groups.tsv")
global_data <-
  vroom("03_results/TARGET-OS_GDC_protein_data.tsv") %>%
  column_to_rownames("hgnc_symbol")

hallmark_mean_groups <-
  vroom("03_results/hallmark_mean_groups.tsv")

mcp_counter <-
  MCPcounter.estimate(global_data, featuresType = "HUGO_symbols") %>%
  t() %>%
  scale() %>%
  as.data.frame() %>%
  rownames_to_column("sample") %>%
  left_join(hallmark_mean_groups)

fill_color <- ggsci::pal_npg()(3)



# MCP for neutrophils
source("01_script/09A_signature_function.R")
stat_dunn <- make_mean_comparison(mcp_counter, "Neutrophils", "group_mean", return_table = TRUE)
stat_dunn <- add_y_position(stat_dunn$dunn) %>%
  mutate(p.adj = insight::format_p(.$p.adj))

# Only add y position, because x position is flawed. stat_pvalue_manual can get automatic position which is group1 and group2 by default.

mcpn_plot <- ggboxplot(
  mcp_counter,
  x = "group_mean",
  y = "Neutrophils",
  fill = "group_mean",
  add = "mean_sd",
  palette = fill_color,
  ggtheme = theme_pubclean(),
  order = c("Low", "Medium", "High"),
  xlab = "",
  legend.title = "Group",
  ylab = "Mean (SD) of Z-score"
) + stat_compare_means() +
  stat_pvalue_manual(stat_dunn, label = "p.adj", step.increase = 0.05)
mcpn_plot


```


```{r cibersortx, cache = TRUE, include=FALSE}
cibersortx <-
  vroom("02_data/CIBERSORT/CIBERSORTx_Adjusted_TARGET-OS.txt")

# CIBERSORTx is run in absolute mode, with batch correction, no quantile
# normalization
cibersortx %<>%
  left_join(hallmark_mean_groups, by = c("Mixture" = "sample"))
population <- cibersortx %>%
  select(`B cells naive`:Neutrophils) %>%
  colnames()



## Make neutrophil plot for cibersortx ====
source("01_script/09A_signature_function.R")
stat_krus <-
  make_mean_comparison(cibersortx, "Neutrophils", "group_mean", return_table = TRUE)
# Kruskal wallis gives p = 0.47, so we cannot do post-hoc analysis.

cibn_plot <- ggboxplot(
  cibersortx,
  x = "group_mean",
  y = "Neutrophils",
  fill = "group_mean",
  add = "mean_sd",
  palette = fill_color,
  ggtheme = theme_pubclean(),
  order = c("Low", "Medium", "High"),
  xlab = "",
  legend.title = "Group",
  ylab = "Mean (SD) of Z-score"
) + stat_compare_means()
cibn_plot

cibersortx_tidy <- cibersortx %>%
  pivot_longer(cols = population, "population") %>%
  select(1, population, value, group_mean) %>%
  mutate(
    group_mean = factor(.data$group_mean,
      levels = c("Low", "Medium", "High")
    ),
    population = fct_reorder(population, value, mean)
  )


ciber_tidy <-
  ggboxplot(cibersortx_tidy,
    "population",
    "value",
    fill = "group_mean",
    legend.title = "Group",
    palette = "npg",
    ylab = "Absolute Score",
    ggtheme = theme_pubr()
  ) + coord_flip()
ggsave("04_figures/immune_deconv/cibersortx_barplot.png")
```



```{r xCell, cache = TRUE, include=FALSE}
librarian::shelf(omnideconv/immunedeconv, xCell)
xcell <- 
  immunedeconv::deconvolute(global_data, "xcell") %>%
  column_to_rownames("cell_type") %>%
  t() %>%
  as.data.frame() %>%
  rownames_to_column("sample") %>%
  left_join(hallmark_mean_groups)
population <- xcell %>%
  select(2:"microenvironment score") %>%
  colnames()

## Make plot for neutrophils xCell ====
stat_krus <-
  make_mean_comparison(xcell, "Neutrophil", "group_mean", return_table = TRUE)
xcelln_plot <- ggboxplot(
  xcell,
  x = "group_mean",
  y = "Neutrophil",
  fill = "group_mean",
  add = "mean_sd",
  palette = fill_color,
  ggtheme = theme_pubclean(),
  order = c("Low", "Medium", "High"),
  xlab = "",
  legend.title = "Group",
  ylab = "Mean (SD) of Z-score"
) + stat_compare_means()

```


```{r immune-plot, fig.cap= "**Immune deconvolution plot of neutrophils.** **A.** MCP-counter. **B.** CIBERSORTx. **C.** xCell. P $\\leq$ 0.05 is considered statistically significant.", cache = TRUE, dependson=c("mcp_counter", "cibersortx", "xCell")}
immune_plot <- ggarrange(mcpn_plot, cibn_plot, xcelln_plot, ncol = 3, nrow = 1, labels = "AUTO")
suppressWarnings(print(immune_plot))
```

#### Survival curve

In order to determine if inflammation groups are linked with increased survival odds, a Kaplan-Meier survival analysis was performed between low and high group of inflammation **(Figure \@ref(fig:survival))**. Log-rank analysis shows that the survival curve between low and high group of inflammation are not statistically different (P = 0.16). However the P value is low enough that it could be considered a trend. Estimation considers 29 patients in the low group and 28 patients in the high group, and estimates that only 9 patients remain alive in the low group while 20 patients are alive in the high group.

```{r survival_code, cache=TRUE, include=FALSE}

librarian::shelf(tidyverse, magrittr, survival, survminer, snakecase, glue, vroom)

survival_data <-
  vroom("../TargetOS-Osteosarcoma/02_data/GDC/GDC_clinical_data/clinical.tsv") %>%
  setNames(to_snake_case(colnames(.))) %>%
  mutate(
    "sample" = map_chr(
      case_submitter_id,
      ~ str_replace(., pattern = "TARGET-40-", replacement = "")
    ),
    .before = 1
  ) %>%
  select(
    sample,
    vital_status,
    days_to_death,
    age_at_diagnosis,
    days_to_last_follow_up
  )
hallmark_mean_groups <-
  vroom("../TargetOS-Osteosarcoma/03_results/hallmark_mean_groups.tsv")

# From ?Surv : The status indicator, normally 0=alive, 1=dead. Other choices are
# TRUE/FALSE (TRUE = death) or 1/2 (2=death)
survival_data <-
  left_join(hallmark_mean_groups, survival_data) %>%
  dplyr::mutate(
    vital_status = case_when(
      vital_status == "Alive" ~ "0",
      vital_status == "Dead" ~ "1"
    ),
    days_to_death = str_replace(days_to_death, "'--", NA_character_),
    days_to_death = as.numeric(days_to_death),
    group_mean = case_when(
      group_mean == "Low" ~ "1",
      group_mean == "Medium" ~ "2",
      group_mean == "High" ~ "3"
    ),
    group_mean = as.numeric(group_mean),
    vital_status = as.numeric(vital_status),
    days_to_last_follow_up = as.numeric(days_to_last_follow_up)
  ) %>%
  drop_na(days_to_last_follow_up) %>%
  filter(!group_mean == 2) %>%
  write_tsv("../TargetOS-Osteosarcoma/03_results/survival_inflammatory_data.tsv")


# make_survplot <- function(quantile)


fit <-
  survfit(Surv(days_to_last_follow_up, event = vital_status) ~ group_mean,
    data = survival_data
  )
summary(fit)
summary(fit)$table

# Change color, linetype by strata, risk.table color by strata
# Testing for trend log rank produces p = 0.20, instead of regular log rank =
# 0.40. Plotting for only two groups produce log rank = 0.16.
# Chi-2 square testing produces p = 0.20.

ggsurv <- ggsurvplot(
  fit,
  pval = TRUE,
  pval.method = TRUE,
  risk.table = TRUE,
  risk.table.col = "group_mean",
  surv.median.line = "hv",
  legend.labs = c("Low", "High"),
  ggtheme = theme_pubr(),
  # fun = "cumhaz",
  palette = "lancet",
  xlim = c(0, 1825)
)
# Save Plot and Table
ggsave(
  "../TargetOS-Osteosarcoma/04_figures/ggplot/survival_plot-inflammation-group_mean.png",
  plot = survminer:::.build_ggsurvplot(ggsurv)
)
# Save plot only
ggsave(
  glue(
    "../TargetOS-Osteosarcoma/04_figures/ggplot/survival_plot-inflammation-group_mean-plot.png"
  ),
  plot = ggsurv$plot,
  dpi = "retina"
)
# Chi-2 square testing
surv_diff <-
  survdiff(Surv(days_to_last_follow_up, event = vital_status) ~ group_mean,
    data = survival_data
  )
```

```{r survival-plot, fig.cap="**Kaplan-Meier survival analysis plot of low vs high group indicate a trend associating inflammatory status with survival prognostic.** Horizontal and vertical axes represent survival times and rates, respectively. Blue and red colors represents low and high inflammation group respectively. Plus signs indicate censored values. Depicted P-values were obtained by the log-rank test. The diagram is cut at 1825 days (5 years). *P* $\\leq$ 0.05 is considered statistically significant."}

suppressWarnings(print(ggsurv))
```

### Similarity of inflammatory signatures

In order to see if the inflammatory signatures used have overlapping
genes or not, a Venn diagram was constructed from the signatures
**(Figure** \@ref(fig:venn-plot)**)**. Overall, the three immune
signatures depicting immune infiltration (immune score), inflammation
response and TNF-α pathway have low overlapping genes and can be
considered different.

```{r venn, include=FALSE}
# 1. Setup ----------------------------------------------------------------

librarian::shelf(tidyverse, tidyestimate, ggVennDiagram, vroom)



# 2. Make Venn diagram for 3 inflammatory signatures -----------------------


inf_response <-
  vroom("02_data/signature/HALLMARK_INFLAMMATORY_RESPONSE.txt",
    delim = "\t"
  ) %>%
  slice(n = -1) %>%
  pull()

# Gene sets used in estimate are located in "gene_sets"
intersect(gene_sets[[2]], inf_response)

tnfa <- vroom("02_data/signature/HALLMARK_TNFA_SIGNALING_VIA_NFKB.txt",
  delim = "\t"
) %>%
  slice(n = -1) %>%
  pull()

comparison_estimate <-
  list(
    "ESTIMATE" = gene_sets[[2]],
    "Hallmark Inflammatory Response" = inf_response,
    "TNF-α signaling" = tnfa
  )

venn_plot <- ggVennDiagram(
  comparison_estimate,
  label_alpha = 0,
) +
  ggplot2::scale_fill_gradient(low = "white", high = "orange") +
  scale_x_continuous(expand = expansion(mult = .5))
ggsave(
  "04_figures/ggplot/Venn_estimate_vs_hallmark_inflammatory_response.png",
  dpi = "retina"
)
```

```{r venn-plot, fig.cap = "Venn diagram comparing three inflammatory signatures."}
suppressWarnings(print(venn_plot))
```

## Biological mechanisms underlying the inflammatory groups

### Differential Gene Expression Analysis

```{r load deseq2, include=FALSE}

if (!require("BiocManager", quietly = TRUE)) {
  install.packages("BiocManager")
}
if (!require("Biobase", quietly = TRUE)) {
  BiocManager::install("Biobase")
}

librarian::shelf(
  tidyverse,
  magrittr,
  DESeq2,
  data.table,
  EnhancedVolcano,
  glue,
  ggpubr,
  ggVennDiagram,
  RSQLite,
  snakecase,
  vroom
)
```

```{r generate_raw_count, cache=TRUE, include=FALSE}
# 2. Generate raw data ONCE -----------------------------------------------
generate_protein_count_mat <- function(path, pattern) {
  files <- list.files(path, pattern, full.names = TRUE, recursive = TRUE, include.dirs = TRUE)
  mat <- as.data.frame(do.call(cbind, lapply(files, function(x) fread(x, stringsAsFactors = FALSE))))
  mat <- mat[-c(1:4), ]
  gene_type <- as.character(mat[, 3])
  rownames(mat) <- mat[, 1]
  mat <- as.data.frame(mat[, seq(4, ncol(mat), 9)])
  mat$gene_type <- gene_type
  mat <- subset(mat, mat$gene_type == "protein_coding")
  mat <- mat[, -c(ncol(mat))]
  return(mat)
}

protein_counts <- generate_protein_count_mat("02_data/GDC/GDC_data/", "\\.rna_seq.augmented_star_gene_counts.tsv$")


# Following step done with protein counts only
file_names <-
  list.files(
    "02_data/GDC/GDC_data/",
    "\\.rna_seq.augmented_star_gene_counts.tsv$",
    full.names = FALSE,
    recursive = TRUE,
    include.dirs = FALSE
  ) %>% sub(".*/", "", .)

samplesheet <-
  read.table(
    "02_data/GDC/GDC_metadata/gdc_sample_sheet.2022-04-29.tsv",
    header = T,
    sep = "\t"
  ) %>%
  .[match(file_names, .$File.Name), ] %>%
  mutate(
    "sample" =
      map_chr(
        Case.ID,
        ~ str_replace(., pattern = "TARGET-40-", replacement = "")
      ),
    .before = 1
  )

protein_counts %<>% set_colnames(samplesheet$sample)
# Read metadata
metadata <-
  readxl::read_xlsx("02_data/metadata/TARGET_OS_ClinicalData_Validation_20211108.xlsx") %>%
  set_names(snakecase::to_snake_case(colnames(.))) %>%
  mutate(
    "sample" = map_chr(
      target_usi,
      ~ str_replace(., pattern = "TARGET-40-", replacement = "")
    ),
    .before = 1
  ) %>%
  select(
    sample,
    age_at_diagnosis_in_days,
    overall_survival_time_in_days,
    time_to_death_in_days,
    time_to_first_relapse_in_days,
    vital_status
  )
# column_to_rownames("sample")

# Drop metadata samples that aren't in the 88 samples in GDC data
metadata %>% filter(sample %in% samplesheet)

# Do we really have 0 samples matching ?


head(fread("02_data/GDC/GDC_data/00411dbf-7487-46ff-b26a-85761719779e/c9372691-13e4-49a3-999c-ca21f54ad988.rna_seq.augmented_star_gene_counts.tsv"))
# We can obtain both raw counts and TPM / FPKM from TARGET-OS data



# Transform the gene_id to gene_name
count_data <- list.files(path = "02_data/GDC/GDC_data/", recursive = TRUE, full.names = TRUE)[1] %>%
  data.table::fread() %>% # data.table::fread works unlike readr::read_tsv here
  .[-c(1:4), ] %>%
  select(gene_id, gene_name) %>%
  right_join(rownames_to_column(protein_counts, "gene_id"))

# Duplicate genes exist in gene_name, we concatenate them so that we don't lose
# information
duplicate_gene <- count_data %>%
  group_by(gene_name) %>%
  filter(n() > 1) %>%
  unite(gene_name, gene_name, gene_id, sep = "-")

# Remove duplicate rows and add the concatenated rows back
full_data <- count_data %>%
  group_by(gene_name) %>%
  filter(!n() > 1) %>%
  bind_rows(duplicate_gene) %>%
  select(-gene_id) %>%
  column_to_rownames("gene_name")

# Remove empty columns with no expression
no_expression <- full_data %>%
  t() %>%
  as.data.frame() %>%
  select(where(~ sum(.) == 0))
glue("{length(no_expression)} genes were found with 0 expression ")
full_data %<>% t() %>%
  as.data.frame() %>%
  select(where(~ sum(.) != 0)) %>%
  t() %>%
  as.data.frame()

raw_data_path <- "03_results/DESeq2_raw_protein_data.tsv"
full_data %>%
  rownames_to_column("gene") %>%
  write_tsv(raw_data_path)
```

```{r deseq2, cache=TRUE, dependson="generate_raw_count", include=FALSE}

raw_data_path <- "03_results/DESeq2_raw_protein_data.tsv"
full_data <- read_tsv(raw_data_path) %>% column_to_rownames("gene")
clinical <- read_tsv("02_data/GDC/GDC_clinical_data/clinical.tsv") %>%
  mutate(
    "sample" =
      map_chr(
        case_submitter_id,
        ~ str_replace(., pattern = "TARGET-40-", replacement = "")
      ),
    .before = 1
  )

inflammatory_group_clinical <- read_tsv("03_results/hallmark_mean_groups.tsv") %>%
  right_join(clinical) %>%
  mutate(group_mean = as.factor(group_mean)) %>%
  mutate(vital_status = as.factor(vital_status))


dds <-
  DESeqDataSetFromMatrix(full_data,
    colData = inflammatory_group_clinical,
    design = ~ group_mean + vital_status,
  )
dds$vital_status <- relevel(dds$vital_status, ref = "Dead")
dds$group_mean <- relevel(dds$group_mean, ref = "Low")
dds <- DESeq(dds)


# DESeq2 results
DESeq2_vital_status <-
  DESeq2::results(dds, contrast = c("vital_status", "Dead", "Alive"))
DESeq2_group_mean_Low_vs_Medium <-
  DESeq2::results(dds, contrast = c("group_mean", "Low", "Medium"))
DESeq2_group_mean_Medium_vs_High <-
  DESeq2::results(dds, contrast = c("group_mean", "Medium", "High"))
DESeq2_group_mean_Low_vs_High <-
  DESeq2::results(dds, contrast = c("group_mean", "Low", "High"))

DESeq2_vital_status_df <- as.data.frame(DESeq2_vital_status)


# Create a list with df_name inside to input into get_DEG_genes
DESeq2_inflammation <- list(
  DESeq2_group_mean_Low_vs_Medium_df = as.data.frame(DESeq2_group_mean_Low_vs_Medium),
  DESeq2_group_mean_Medium_vs_High_df = as.data.frame(DESeq2_group_mean_Medium_vs_High),
  DESeq2_group_mean_Low_vs_High_df = as.data.frame(DESeq2_group_mean_Low_vs_High)
) %>%
  Map(cbind, ., df_name = names(.)) %>%
  map(drop_na)

DESeq2_inflammation %>%
  map_dfr(~ rownames_to_column(.x, "gene")) %>%
  write_tsv("../TargetOS-Osteosarcoma/03_results/DESeq2_genes/DEG_results/DESeq2_inflammation_TARGET-OS.tsv")


# Function to split results into up and downregulated genes
get_DEG_genes <-
  function(data,
           condition = NULL,
           write = TRUE,
           return_all_DEG = FALSE,
           padj_cutoff = 0.05,
           lfc_cutoff = 1,
           use_list = FALSE) {

    # Use use_list == TRUE if using inside purrr::map or lapply
    df_name <- deparse(substitute(data))
    if (use_list == TRUE) {
      df_name <- distinct(data, df_name) %>% pull()
    }


    # Failsafe to ensure "tidy" format, rownames are assumed to be genes
    # This is useful when binding gene in a single df, where genes are duplicates
    # This ensures the rest of the function works in tidy and non tidy df
    if (tibble::has_rownames(data) == TRUE) {
      data %<>% rownames_to_column("gene")
    }


    file_path <- "03_results/DESeq2_genes/"
    dir.create(file_path, showWarnings = FALSE)
    if (!is.null(condition)) {
      condition_name <- condition
    } else {
      condition_name <-
        str_extract(df_name, "[[:alpha:]]*_vs_[[:alpha:]]*")
    }


    # log2(1) = 2 in FoldChange
    # FDR with BH by default in DESeq2
    up_reg <- filter(data, padj <= padj_cutoff & log2FoldChange >= lfc_cutoff) %>%
      mutate("condition" = condition_name)
    down_reg <- filter(data, padj <= padj_cutoff & log2FoldChange <= -lfc_cutoff) %>%
      mutate("condition" = condition_name)


    if (write == TRUE) {
      up_reg %>%
        select(gene) %>%
        write_tsv(
          glue(
            "{file_path}upregulated_genes-{df_name}.tsv"
          ),
          col_names = FALSE
        )
      down_reg %>%
        select(gene) %>%
        write_tsv(
          glue(
            "{file_path}downregulated_genes-{df_name}.tsv"
          ),
          col_names = FALSE
        )

      DEG_gene <- bind_rows(up_reg, down_reg)

      DEG_gene %>%
        pull(gene) %>%
        tibble() %>%
        write_tsv(glue("{file_path}DEG_genes-{df_name}.tsv"),
          col_names = FALSE
        )
    }

    cat(
      glue("Gene list obtained for {df_name}.
           There is {nrow(up_reg)} upregulated genes.
           There is {nrow(down_reg)} downregulated genes.
           Gene list saved in {file_path}.\n

           ")
    )
    if (return_all_DEG == TRUE) {
      return(DEG_gene)
    }

    list(up_regulated = up_reg, down_regulated = down_reg) %>%
      return()
  }

# Return a list with separated up and downregulated genes and write down genes
# for ORA (Over Representation Analysis)
DESeq2_inflammation_DEG <- DESeq2_inflammation %>%
  purrr::map(get_DEG_genes, use_list = TRUE)



## Plot volcano plot ======================================================

plot_volcano <- function(data, use_list = TRUE, tidy = FALSE) {
  df_name <- deparse(substitute(data))
  if (use_list == TRUE) {
    df_name <- distinct(data, df_name) %>% pull()
  }

  if (tidy == TRUE) {
    label_name <- dplyr::pull(data, 1)
  } else {
    label_name <- row.names(data)
  }

  message(glue("Plotting {df_name}"))
  condition_name <-
    str_extract(df_name, "[[:alpha:]]*_vs_[[:alpha:]]*")

  file_dir <- "04_figures/DESeq2_results/"

  volcano <- EnhancedVolcano(
    data,
    lab = label_name,
    x = "log2FoldChange",
    y = "pvalue",
    subtitle = "",
    pointSize = 2,
    pCutoff = 0.05,
    pCutoffCol = "padj",
    FCcutoff = 1,
    title = glue("{to_any_case(condition_name, case = 'title')}"),
    drawConnectors = TRUE,
    widthConnectors = 1.0,
    colConnectors = "black",
    arrowheads = FALSE,
    gridlines.major = FALSE,
    gridlines.minor = FALSE,
    boxedLabels = TRUE,
  )
  volcano_path <- glue("{file_dir}volcano_plot-{condition_name}.png")
  ggsave(volcano_path,
    height = 10,
    width = 10,
    dpi = "retina"
  )
  print(glue("Volcano plot saved in {volcano_path}"))

  return(volcano)
}

volcano_list <- map(DESeq2_inflammation, plot_volcano)


volc_plot <- ggarrange(
  plotlist = volcano_list,
  ncol = 3,
  nrow = 1,
  align = "hv",
  labels = c("A", "B", "C"),
  common.legend = TRUE
)

volc_lh <- ggarrange(volcano_list[[3]])


ggsave("04_figures/DESeq2_results/volcano_plot-inflammatory_group.png",
  height = 10,
  width = 18
)
```

```{r volc-plot, echo=FALSE, fig.height=6, fig.width=6, dependson="deseq2", fig.cap="**Volcano plot of the differentially expressed genes in Low vs High condition. Negative Log~2~ of fold change represent a gene that is more differentially expressed Low condition, and _vice versa_. ** P $\\leq$ 0.05 and Log~2~ fold change $\\leq$ 1 or $\\geq$ 1 was used for cutoff."}

suppressWarnings(print(volc_lh))
```

A differential gene expression analysis was performed in Low versus High
group.

### Gene Set Enrichment Analysis (GSEA)

```{r gsea, cache=TRUE, include=FALSE}


# 1. Setup ----------------------------------------------------------------

librarian::shelf(
  tidyverse,
  glue,
  magrittr,
  msigdbr,
  fgsea,
  clusterProfiler,
  enrichplot,
  snakecase,
  ggridges,
  vroom
)


# Read data
data <-
  vroom("03_results/DESeq2_genes/DEG_results/DESeq2_inflammation_TARGET-OS.tsv")
data_low_vs_high <-
  data %>% filter(df_name == "DESeq2_group_mean_Low_vs_High_df") # %>%
# filter(gene %in% hallmark_inflammatory)
# Note that ICAM4 doesn't appear thus we have a gene list of 199 genes
gene_list_inflam <- data_low_vs_high %>%
  drop_na(log2FoldChange) %>%
  select(gene, log2FoldChange)

# The log2FC of all genes is sorted from high to low, in order to input a pre-ranked in a way that upregulated genes have lower ranks than downregulated genes.
gene_list_inflam %<>%
  pull(log2FoldChange) %>%
  sort(decreasing = TRUE) %>%
  set_names(gene_list_inflam$gene)


gene_list_diap <- vroom("03_results/DESeq2_genes/DEG_results/DESeq2_diapedesis_TARGET-OS.tsv") %>%
  dplyr::select(gene, log2FoldChange)
gene_list_diap %<>%
  pull(log2FoldChange) %>%
  sort(decreasing = TRUE) %>%
  set_names(gene_list_diap$gene)



# 2. msigdbr --------------------------------------------------------------


# Get pathway from source "01_script/get_msigdb_signature.R"
msigdb_files <-
  list.files("02_data/msigdb_signature/", full.names = TRUE)
all_signatures <- msigdb_files %>%
  map(vroom) %>%
  set_names(basename(tools::file_path_sans_ext(msigdb_files)))


# Make GSEA and GSEA Table
make_gsea_clusterProfiler <-
  function(gene_list,
           msigdb_signature,
           dir_save = "04_figures/GSEA/clusterProfiler/",
           get_gsea_plot = FALSE) {
    # Traditional running enrichment score

    msigdb_signature_df <- bind_rows(msigdb_signature)

    set.seed(123)
    gsea_msig <-
      GSEA(
        gene_list,
        TERM2GENE = msigdb_signature_df,
        minGSSize = 1,
        maxGSSize = 10000,
        verbose = TRUE,
        seed = TRUE,
        by = "fgsea",
        pvalueCutoff = 1
        # adjusted pvalue cutoff to allow every signatures in @result tab
      )

    if (get_gsea_plot == TRUE) {
      # Single GSEA plot for each gene set
      gsea_msig@result[["ID"]] %>%
        map2(seq_along(.), ~ {
          gseaplot2(
            gsea_msig,
            geneSetID = .y,
            title = glue("{.x}"),
            pvalue_table = TRUE
          )
          dir.create(dir_save, showWarnings = FALSE)
          ggsave(glue("{dir_save}GSEA-{.x}.png"), width = 10)
          print(glue("Single GSEA plot saved for {.x}"))
        })
    }
    # Combined GSEA plot for each separate element in msigdb_signature list
    iwalk(msigdb_signature, ~ {
      signature_group <- distinct(., gs_name) %>% pull()
      signature_index_id <- which(gsea_msig@result[["ID"]] %in% signature_group)
      gseaplot2(
        gsea_msig,
        geneSetID = signature_index_id,
        title = glue("{.y}"),
        pvalue_table = TRUE
      )

      dir.create(glue("{dir_save}combined_GSEA/"), showWarnings = FALSE)
      ggsave(glue("{dir_save}combined_GSEA/GSEA_combined-{.y}.png"),
        width = 12
      )
      print(glue("Combined GSEA plot saved for {.y}"))
    })

    # Ridgeplot
    ridgeplot(gsea_msig, orderBy = "NES", decreasing = TRUE)
    dir.create(glue("{dir_save}ridgeplot/"), showWarnings = FALSE)
    ggsave(glue("{dir_save}ridgeplot/GSEA-ridgeplot.png"))
    print(glue("Ridge plot"))

    # Make p significant table for easy visualization
    gsea_msig_sign <- gsea_msig@result %>%
      rownames_to_column("Pathway") %>%
      mutate(
        p.sign = case_when(
          p.adjust <= 0.001 ~ "***",
          p.adjust <= 0.01 ~ "**",
          p.adjust <= 0.1 ~ "*",
          TRUE ~ "ns"
        ),
        Pathway = to_title_case(Pathway)
      ) %>%
      dplyr::select(Pathway,
        "Set Size" = setSize,
        NES,
        p.adjust,
        qvalues,
        p.sign
      )
    dir.create(glue("{dir_save}GSEA_table/"), showWarnings = FALSE)

    # Do a separate table for each sublist with p.sign
    iwalk(msigdb_signature, ~ {
      signature_group <- distinct(.x, gs_name) %>%
        pull() %>%
        to_title_case()
      html_file <- glue("{dir_save}GSEA_table/GSEA_table-{.y}.html")
      gsea_msig_sign %>%
        filter(Pathway %in% signature_group) %>%
        kableExtra::kbl("html") %>%
        kableExtra::kable_styling() %>%
        kableExtra::save_kable(html_file)

      # Instead of using save_kable to png directly, which doesn't work, we use a
      # workaround by saving html first and using webshot to save png, which is what
      # the function is supposed to do automatically anyway
      webshot::webshot(
        html_file,
        glue("{dir_save}GSEA_table/GSEA_table_sign-{.y}.png")
      )
      print(glue("GSEA Table saved for {.y} in {dir_save}GSEA_table/."))
    })
    return(gsea_msig_sign)
  }



gsea_df <- make_gsea_clusterProfiler(gene_list_inflam, all_signatures,
  dir_save = "04_figures/GSEA/inflammation/clusterProfiler/"
)
```

GSEA was performed on `r nrow(gsea_df)` selected signatures from MSigDB,
based on the theme of osteosarcoma, angiogenesis, neutrophils,
migration, hypoxia and inflammation. Only significant pathways are
reported in the table. Certain pathways are not significant but
relevant, such as "Gobp Positive Regulation of Vascular Associated
Smooth Muscle Cell Proliferation" (P = 0.13), "Gobp Positive Regulation
of Inflammatory Response", and all other pathways concerning dendritic,
lymphocyte, monocyte, macrophage chemotaxis and migration.

Interestingly, there is no found significant pathway relating to
positive regulation of inflammation, but there are significant pathways
relating to negative regulation of inflammation, indicating that in the
high group, there is negative regulation of inflammation. Similarly, the
only signature with a negative enrichment score is "Gobp Positive
Regulation of Neutrophil Activation". It is also notable that the
signature *Hp Osteosarcoma* in GSEA is not significantly different (*P =
0.38*).

```{r gsea-table, dependson="gsea", fig.cap="GSEA table"}
gsea_df %>%
  filter(p.adjust <= 0.10) %>%
  dplyr::select(-qvalues) %>%
  kableExtra::kbl(
    format = "latex",
    caption = glue("Results of GSEA by clusterProfiler, pre-ranked by descending order of log2 of fold change for genes differentially expressed in low vs high condition. Genes at the top of the list are thus differentially expressed in the high group, and vice versa. Only significant pathways are shown, out of {nrow(gsea_df)} selected pathways. P.adjust ≤ 0.10 is considered significant."),
    digits = 2,
    booktabs = TRUE,
    # longtable = TRUE
  )
```

```{r write_packages}
knitr::write_bib(c(.packages()), "../R-Markdown-Report/bibliography/packages.bib")
```
