---
title: ''
output: 
  bookdown::pdf_document2:
    latex_engine: xelatex
    number_sections: yes
    toc: no
---

# Results

Some more guidelines from the School of Geosciences.

This section should summarize the findings of the research referring to
all figures, tables and statistical results (some of which may be placed
in appendices).

-   include the primary results, ordered logically - it is often useful
    to follow the same order as presented in the methods.
-   alternatively, you may find that ordering the results from the most
    important to the least important works better for your project.
-   data should only be presented in the main text once, either in
    tables or figures; if presented in figures, data can be tabulated in
    appendices and referred to at the appropriate point in the main
    text.

**Often, it is recommended that you write the results section first, so
that you can write the methods that are appropriate to describe the
results presented. Then you can write the discussion next, then the
introduction which includes the relevant literature for the scientific
story that you are telling and finally the conclusions and abstract --
this approach is called writing backwards.**

## Determination of inflammatory groups representing intratumor inflammatory status

Functional clusters of osteosarcoma samples were created using k-means
clustering of from MDS visualization of the Hallmark Inflammatory
Response signature.

```{r setup, include=FALSE}
root_dir <- "../TargetOS-Osteosarcoma/"
librarian::shelf(
  tidyverse, magrittr, ggplot2, ggrepel, pheatmap, viridis, ggpubr,
  snakecase, glue, rstatix, gridExtra, ggpmisc, ggplotify, patchwork
)
knitr::opts_knit$set(root.dir = root_dir)
knitr::opts_knit$set(autodep = TRUE)

setwd(root_dir)
# Load packages
source("01_script/04_pheatmap.R")
source("01_script/05_make_MDS.R")
source("01_script/09A_signature_function.R")
source("01_script/12_optimal_kcluster.R")
```

```{r signature_construction, cache = TRUE, include=FALSE, cache.rebuild=TRUE}

# Load imported data
data_path <- "03_results/TARGET-OS_GDC_protein_data.tsv"
global_data <- vroom(data_path) %>%
  column_to_rownames("hgnc_symbol") %>%
  t() %>%
  as.data.frame()


# Transform data in Z-scale
global_data_scaled <- global_data %>%
  rownames_to_column(var = "sample") %>%
  dplyr::select(-sample) %>%
  scale(center = TRUE, scale = TRUE) %>%
  bind_cols("sample" = row.names(global_data)) %>%
  column_to_rownames("sample")
global_data_scaled %<>% .[, colSums(is.na(.)) < nrow(.)] # Should be obsolete

remove_genes <- remove_unknown_genes(get_list_unknown_genes = TRUE) %>%
  extract2("Hallmark_Inflammatory_Response")


# Read data and remove unknown genes
hallmark_inflammatory <- vroom("02_data/msigdb_signature/msigdb_signature.tsv") %>%
  filter(
    gs_name == "hallmark_inflammatory_response",
    !gene_symbol %in% remove_genes
  )
hallmark_inflammatory <- global_data_scaled[, hallmark_inflammatory$gene_symbol]


# Construction of groups by mean of Z-score
hallmark_mean_groups <- hallmark_inflammatory %>%
  rownames_to_column("sample") %>%
  pivot_longer(!1, names_to = "markers") %>%
  group_by(sample) %>%
  summarise(
    median = median(value),
    mean = mean(value)
  ) %>%
  mutate(group_mean = as.factor(ntile(mean, 3))) %>%
  arrange(group_mean)
# dplyr::ntile splits input vector into n even groups


# Rename numbers to Low, Medium and High group
hallmark_mean_groups %<>%
  mutate(
    group_mean = str_replace(group_mean, "1", "Low"),
    group_mean = str_replace(group_mean, "2", "Medium"),
    group_mean = str_replace(group_mean, "3", "High"),
  ) %>% write_tsv("03_results/hallmark_mean_groups.tsv")



# Compute hallmark_mean_groups for heatmap
mds_data <- hallmark_heatmap(k_cluster = 8, scale = TRUE)
hallmark_cluster <- mds_data %>%
  dplyr::select(sample, cluster) %>%
  arrange(cluster) %>%
  dplyr::rename(cluster_8 = cluster)
hallmark_mean_groups %<>% left_join(hallmark_cluster) %>% arrange(mean)


# Histogram of hallmark mean with MDS clusters
hmg_mds_8 <- ggbarplot(hallmark_mean_groups,
  x = "sample",
  y = "mean",
  xlab = "Sample",
  ylab = "Mean (Z-Score)",
  fill = "cluster_8",
  palette = "npg",
  legend.title = "MDS Cluster",
) +
  theme(
    axis.ticks = element_blank(),
    axis.text.x = element_blank()
  )
ggsave("04_figures/ggplot/hallmark_mean_vs_sample+MDS_8_clusters.png",
  dpi = "retina"
)


## Histogram of hallmark groups of inflammation ====
hmg <- ggbarplot(hallmark_mean_groups,
  x = "sample",
  y = "mean",
  xlab = "Sample",
  ylab = "Mean (Z-Score)",
  fill = "group_mean",
  palette = "npg",
  legend.title = "Group"
) +
  theme(
    axis.ticks = element_blank(),
    axis.text.x = element_blank()
  )
ggsave("04_figures/ggplot/hallmark_mean_vs_sample+group_mean.png",
  dpi = "retina"
)



### Compute kruskal test ####
stat_table <- make_mean_comparison(hallmark_mean_groups, "mean", "group_mean")

# Compute elbow, mds and heatmap
elbow_hi <- elbow_method(hallmark_inflammatory)
mds_8 <- hallmark_heatmap(k_cluster = 8, scale = TRUE, return_plot = TRUE)


# Compute heatmap
hallmark_annotation <- hallmark_mean_groups %>%
  column_to_rownames("sample") %>%
  select("Group" = "group_mean") %>%
  `levels<-`(c("Low", "Medium", "High"))

hallmark_inflammatory <- vroom("02_data/msigdb_signature/msigdb_signature.tsv") %>%
  filter(
    gs_name == "hallmark_inflammatory_response",
    !gene_symbol %in% remove_genes
  )
hallmark_inflammatory <- global_data_scaled[, hallmark_inflammatory$gene_symbol] %>%
  t()
hallmark_inflammatory <- hallmark_inflammatory[, match(
  row.names(hallmark_annotation),
  colnames(hallmark_inflammatory)
)]



### Colors for pheatmap group mean annotation ####
gm_colors <- list("Group" = c(
  "High" = ggsci::pal_npg()(3)[1],
  "Medium" = ggsci::pal_npg()(3)[2],
  "Low" = ggsci::pal_npg()(3)[3]
))

ph <- pheatmap(
  hallmark_inflammatory,
  annotation_col = hallmark_annotation,
  main = " ",
  annotation_names_col = FALSE,
  annotation_colors = gm_colors,
  labels_row = "Gene",
  angle_col = "0",
  color = magma(256),
  cluster_cols = TRUE,
  show_colnames = FALSE,
  show_rownames = FALSE,
  cluster_rows = TRUE,
  border_color = NA,
  width = 15,
  filename = glue(
    "04_figures/pheatmap/pheatmap-hallmark_group_mean_cluster_cols.png"
  )
)


ph <- as.ggplot(ph) # Transform pheatmap intp a ggplot object
# p <- ggarrange(elbow_hi, mds_8[[2]], hmg, hmg_mds_8, labels = "AUTO")
#
# suppressWarnings(print(p)) # Used to suppress ggrepel warnings
# ggarrange(ph, labels = ("E"))
patchwork <- elbow_hi + mds_8[[2]] + hmg + hmg_mds_8 + ph
layout <- "
AAABBB
CCCDDD
EEEEEE"
patchwork <- patchwork +
  plot_layout(design = layout, heights = c(1, 1, 3)) +
  plot_annotation(tag_levels = "A") &
  theme(plot.tag = element_text(face = "bold"))
```

Inflammatory groups characterizing the intensity of inflammatory status
in tumors were created by first creating groups of inflammatory status.
The number of groups were tried using k-means clustering algorithm on a
MDS visualization of the scaled by Z-score of the 88 tumor samples for
the hallmark inflammatory response signature from MSigDB, containing 200
genes. ICAM4 was notably not detected in the dataset in the TARGET-OS
cohort. Thus, 199 genes from the signature were used.

The groups are chosen from Figure 1.C as they are relevant as they
correspond fairly well to functional groups, defined by k-means
clustering based on MDS visualization **(Figure**
\@ref(fig:inflammatory-plot)**)**. Each sample is thus attributed to its
inflammatory status and this group will be subsequently used for the
following results.

```{r inflammatory-plot, echo=FALSE, fig.cap="Construction of inflammatory groups. E. Heatmap of the Hallmark Inflammatory Response signature with samples annotated to their corresponding inflammatory groups. Rows correspond to genes and columns correspond to samples.", fig.height=12, fig.width=10, dependson= "signature_construction"}

suppressWarnings(print(patchwork))
```

```{r hp_osteosarcoma, include=FALSE, cache = TRUE}

removed_genes <- remove_unknown_genes()
hp_osteosarcoma <- make_signature_list(removed_genes) %>%
  extract2("Hp_Osteosarcoma") %>%
  pivot_wider() %>%
  as.data.frame() %>%
  tibble::column_to_rownames("sample")

hm_ost <- make_pheatmap(hp_osteosarcoma,
  clustering_method = "hclust",
  pheatmap_method = "unclustered_samples",
  cluster_column = FALSE,
  transpose = TRUE,
  annotation_col = hallmark_annotation,
  annotation_colors = gm_colors,
  add_filename = "hallmark_annotation",
  pheatmap_title = " ",
  width = 10,
  border_col = NA,
  return_plot = TRUE
)

hm_ost_c <- make_pheatmap(hp_osteosarcoma,
  clustering_method = "hclust",
  pheatmap_method = "unclustered_samples",
  cluster_column = TRUE,
  transpose = TRUE,
  annotation_col = hallmark_annotation,
  annotation_colors = gm_colors,
  add_filename = "hallmark_annotation-clustered",
  pheatmap_title = " ",
  width = 10,
  border_col = NA,
  return_plot = TRUE
)


# Plot osteosarcoma type heatmap
osteosarcoma_annotation <- get_osteosarcoma_type()[[2]] %>%
  filter(!type %in% c("TILs Markers", "Osteoclastic Markers")) %>%
  rownames_to_column("sample") %>%
  dplyr::rename("Type" = type)
osteosarcoma_type <- get_osteosarcoma_type()[[1]] %>%
  dplyr::select(osteosarcoma_annotation$sample) %>%
  rownames_to_column("sample")
osteosarcoma_type_mean_groups <-
  left_join(hallmark_mean_groups, osteosarcoma_type) %>%
  dplyr::select(sample, "cluster" = group_mean, LUM:last_col())


hallmark_cluster <- hallmark_mean_groups %>%
  select(sample, "Group" = group_mean) %>%
  column_to_rownames("sample")
hallmark_comparison <- osteosarcoma_type_mean_groups %>%
  select(sample, LUM:last_col()) %>%
  column_to_rownames("sample")
osteosarcoma_annotation <-
  column_to_rownames(osteosarcoma_annotation, "sample")

hm_os_type_mean <- make_pheatmap(
  osteosarcoma_type_mean_groups,
  clustering_method = "manual",
  pheatmap_method = "unclustered_genes",
  annotation_row = osteosarcoma_annotation,
  pheatmap_title = " ",
  col_order = c("Low", "Medium", "High"),
  transpose = TRUE,
  add_filename = "order",
  return_plot = TRUE
)

hm_os_type <- make_pheatmap(osteosarcoma_type,
  clustering_method = "hclust",
  pheatmap_method = "unclustered_samples",
  annotation_col = hallmark_cluster,
  annotation_row = osteosarcoma_annotation,
  annotation_colors = gm_colors,
  pheatmap_title = " ",
  cluster_column = TRUE,
  cluster_rows = TRUE,
  transpose = TRUE,
  show_col = FALSE,
  add_filename = "hallmark_annotation-cluster",
  width = 10,
  border_col = NA,
  return_plot = TRUE
)
```

```{r osteosarcoma-plot, echo = FALSE, fig.height=14, fig.width=12, fig.cap="**Heatmap of HP Osteosarcoma signature with samples annotated to their respective inflammatory groups.**"}

hm_ost %<>% as.ggplot()
hm_ost_c %<>% as.ggplot()
hm_os_type %<>% as.ggplot()
hm_os_type_mean %<>% as.ggplot()
pho <- ggarrange(hm_ost, hm_ost_c, hm_os_type, hm_os_type_mean,
  labels = "AUTO", common.legend = TRUE
)

suppressWarnings(print(pho))
```

## Characterization of osteosarcomas associated to inflammatory status

In order to characterize osteosarcomas, the *Hp Osteosarcoma* gene
signature from MSigDB was used to see whether the inflammatory groups
can be related to gene expression from this signature. Visually, the
heatmap representing the gene signature, annotated with the inflammatory
groups, does seem to indicate that the samples express different genes
between Low, Medium and High inflammation group (**Fig.**
\@ref(fig:osteosarcoma-plot)**A**). However, the dendrogram clustering
the samples indicates that the gene signature does not cluster well with
the inflammatory annotations. However, despite high heterogeneity
between samples and inflammatory status,

Comparison of the expression of specific osteosarcoma markers relating
to osteoblastic, chondroblastic, fibroblastic markers has also been
done, through a heatmap representation. Hierarchical clustering of the
samples does not appear to be associated with corresponding inflammatory
status. However it does reveal that there are groups of osteoblastic,
chondroblastic and fibroblastic osteosarcomas which is expected
(**Fig.** \@ref(fig:osteosarcoma-plot)**C**).

The mean of markers of proliferation (MKI67, PCNA, TOP2A) associated to
osteosarcomas have been compared to inflammatory status, along with the
mean of the three markers. Kruskal-Wallis testing is significant (p =
0.00968) and post-hoc Dunn analysis reveals that the mean of the
proliferation markers between low and high group is significantly
different (p = 0.016). The data suggests that proliferation is hindered
when inflammatory status is high in the osteosarcoma samples.

## Characterization of intra-tumor inflammation associated to inflammatory status

### General relationship of inflammatory status with immune response

#### Relationship with ESTIMATE and inflammatory signatures

Using ESTIMATE algorithm from *tidyestimate* R package, an immune score
has been calculated for each sample which reflects the immune
infiltration in a given tumor sample. The violin plot represents the
values obtained for each inflammatory group **(Fig.**
\@ref(fig:estimate-violin)**)**.

```{r estimate, include=FALSE, dependson="signature_construction"}


# Violin plot for ESTIMATE ---------------------------------------------

estimate_data <- vroom("03_results/estimate/estimate_score.tsv") %>%
  select(sample, immune) %>%
  left_join(rownames_to_column(hallmark_annotation, "sample"))


stat_tukey <-
  make_mean_comparison(estimate_data, "immune", "Group", return_tukey = TRUE) %>% add_xy_position(x = "Group")
ve <-
  ggviolin(
    estimate_data,
    "Group",
    "immune",
    ylab = "Immune Score",
    fill = "Group",
    add = "boxplot",
    order = c("Low", "Medium", "High")
  ) +
  stat_compare_means(
    method = "anova",
    label.x.npc = "left",
    label.y.npc = "top"
  ) +
  stat_pvalue_manual(stat_tukey,
    label = "p.adj",
    # # y.position = c(2900, 3600, 3200),
    step.increase = 0.1
  )

vep <- ggarrange(ve)
```

```{r estimate-violin, fig.cap="**Violin plot of ESTIMATE score for each inflammatory group.** ANOVA was performed followed by Tukey's post-hoc analysis. P < 0.05 is considered statistically significant."}

suppressWarnings(print(vep))
```

#### Immune abundance by immune deconvolution algorithm

Immune cell abundance can be determined thanks to various immune
deconvolution algorithm on TPM normalized bulk-RNASeq. Here,
MCP-counter, CIBERSORTx and xCell have been tried. In MCP-counter, the
abundance of neutrophil is increased in the High group compared to the
Low (P = )

```{r mcp_counter, cache=TRUE, include=FALSE, dependson= "signature_construction"}

if (!require("MCPcounter", quietly = TRUE)) {
  remotes::install_github("ebecht/MCPcounter", ref = "master", subdir = "Source")
}

librarian::shelf(
  tidyverse,
  magrittr,
  MCPcounter,
  ggplot2,
  ggpubr,
  ggnewscale,
  glue,
  vroom
)


hallmark <- vroom("03_results/hallmark_mean_groups.tsv")
global_data <-
  vroom("03_results/TARGET-OS_GDC_protein_data.tsv") %>%
  column_to_rownames("hgnc_symbol")

hallmark_mean_groups <-
  vroom("03_results/hallmark_mean_groups.tsv")

mcp_counter <-
  MCPcounter.estimate(global_data, featuresType = "HUGO_symbols") %>%
  t() %>%
  scale() %>%
  as.data.frame() %>%
  rownames_to_column("sample") %>%
  left_join(hallmark_mean_groups)

population <- mcp_counter %>%
  select(-sample) %>%
  select(!median:last_col()) %>%
  colnames()

fill_color <- ggsci::pal_npg()(3)


make_immune_deconv_plot <-
  function(data,
           group,
           population,
           ylab,
           width = 20,
           height = 15) {
    df_name <- deparse(substitute(data))

    if (has_rownames(data)) {
      data %<>% column_to_rownames(names(select(data, 1)))
    }

    immune_plot <- ggboxplot(
      data,
      x = group,
      y = population,
      fill = "group_mean",
      add = "mean_sd",
      palette = fill_color,
      ggtheme = theme_pubclean(),
      order = c("Low", "Medium", "High"),
      xlab = "",
      legend.title = "Group",
      ylab = ylab
    )

    # Choose for which group wilcoxon test will be performed
    my_comparisons <-
      list(c("Low", "Medium"), c("Medium", "High"), c("Low", "High"))
    symnum_args <-
      list(
        cutpoints = c(0, 0.0001, 0.001, 0.01, 0.05, 1),
        symbols = c("****", "***", "**", "*", "ns")
      )

    # Test used by default is Kruskal-Wallis
    immune_plot %<>% map(~ {
      .x + stat_compare_means(
        label = "p.format",
        label.x.npc = "center",
        label.y.npc = 0.95
      ) +
        stat_compare_means(
          comparisons = my_comparisons,
          symnum.args = symnum_args,
          hide.ns = TRUE
        )
    })

    plot <- ggarrange(
      plotlist = immune_plot,
      common.legend = TRUE,
      align = "hv"
    )
    file_save <-
      glue("04_figures/immune_deconv/immune_abundance_{df_name}.png")
    ggsave(file_save,
      width = width,
      height = height,
      dpi = "retina"
    )
    print(glue("Plot saved in {file_save}"))
    return(plot)
  }


mcp_plot <- make_immune_deconv_plot(mcp_counter, "group_mean", population, "Mean (SD) of Z-score")
```

```{r cibersortx, cache = TRUE, include=FALSE}
cibersortx <-
  vroom("02_data/CIBERSORT/CIBERSORTx_Adjusted_TARGET-OS.txt")

# CIBERSORTx is run in absolute mode, with batch correction, no quantile
# normalization
cibersortx %<>%
  left_join(hallmark_mean_groups, by = c("Mixture" = "sample"))
population <- cibersortx %>%
  select(`B cells naive`:Neutrophils) %>%
  colnames()

ciber_plot <- make_immune_deconv_plot(cibersortx, "group_mean", population, "Absolute Score",
  height = 20
)


cibersortx_tidy <- cibersortx %>%
  pivot_longer(cols = population, "population") %>%
  select(1, population, value, group_mean) %>%
  mutate(
    group_mean = factor(.data$group_mean,
      levels = c("Low", "Medium", "High")
    ),
    population = fct_reorder(population, value, mean)
  )


ciber_tidy <-
  ggboxplot(cibersortx_tidy,
    "population",
    "value",
    fill = "group_mean",
    legend.title = "Group",
    palette = "npg",
    ylab = "Absolute Score",
    ggtheme = theme_pubr()
  ) + coord_flip()
ggsave("04_figures/immune_deconv/cibersortx_barplot.png")
```

```{r immune-plot, fig.height=10, fig.cap= "Immune deconvolution plot. (A) MCP-counter", cache = TRUE, dependson=c("mcp_counter", "cibersortx")}
immune_plot <- ggarrange(mcp_plot, ncol = 1, labels = "AUTO")
suppressWarnings(print(immune_plot))
```

#### Survival curve

```{r survival_code, cache=TRUE, include=FALSE}

librarian::shelf(tidyverse, magrittr, survival, survminer, snakecase, glue, vroom)

survival_data <-
  vroom("../TargetOS-Osteosarcoma/02_data/GDC/GDC_clinical_data/clinical.tsv") %>%
  setNames(to_snake_case(colnames(.))) %>%
  mutate(
    "sample" = map_chr(
      case_submitter_id,
      ~ str_replace(., pattern = "TARGET-40-", replacement = "")
    ),
    .before = 1
  ) %>%
  select(
    sample,
    vital_status,
    days_to_death,
    age_at_diagnosis,
    days_to_last_follow_up
  )
hallmark_mean_groups <-
  vroom("../TargetOS-Osteosarcoma/03_results/hallmark_mean_groups.tsv")

# From ?Surv : The status indicator, normally 0=alive, 1=dead. Other choices are
# TRUE/FALSE (TRUE = death) or 1/2 (2=death)
survival_data <-
  left_join(hallmark_mean_groups, survival_data) %>%
  dplyr::mutate(
    vital_status = case_when(
      vital_status == "Alive" ~ "0",
      vital_status == "Dead" ~ "1"
    ),
    days_to_death = str_replace(days_to_death, "'--", NA_character_),
    days_to_death = as.numeric(days_to_death),
    group_mean = case_when(
      group_mean == "Low" ~ "1",
      group_mean == "Medium" ~ "2",
      group_mean == "High" ~ "3"
    ),
    group_mean = as.numeric(group_mean),
    vital_status = as.numeric(vital_status),
    days_to_last_follow_up = as.numeric(days_to_last_follow_up)
  ) %>%
  drop_na(days_to_last_follow_up) %>%
  filter(!group_mean == 2) %>%
  write_tsv("../TargetOS-Osteosarcoma/03_results/survival_inflammatory_data.tsv")


# make_survplot <- function(quantile)


fit <-
  survfit(Surv(days_to_last_follow_up, event = vital_status) ~ group_mean,
    data = survival_data
  )
summary(fit)
summary(fit)$table

# Change color, linetype by strata, risk.table color by strata
# Testing for trend log rank produces p = 0.20, instead of regular log rank =
# 0.40. Plotting for only two groups produce log rank = 0.16.
# Chi-2 square testing produces p = 0.20.

ggsurv <- ggsurvplot(
  fit,
  pval = TRUE,
  pval.method = TRUE,
  risk.table = TRUE,
  risk.table.col = "group_mean",
  surv.median.line = "hv",
  legend.labs = c("Low", "High"),
  ggtheme = theme_pubr(),
  # fun = "cumhaz",
  palette = "lancet",
  xlim = c(0, 1825)
)
# Save Plot and Table
ggsave(
  "../TargetOS-Osteosarcoma/04_figures/ggplot/survival_plot-inflammation-group_mean.png",
  plot = survminer:::.build_ggsurvplot(ggsurv)
)
# Save plot only
ggsave(
  glue(
    "../TargetOS-Osteosarcoma/04_figures/ggplot/survival_plot-inflammation-group_mean-plot.png"
  ),
  plot = ggsurv$plot,
  dpi = "retina"
)
# Chi-2 square testing
surv_diff <-
  survdiff(Surv(days_to_last_follow_up, event = vital_status) ~ group_mean,
    data = survival_data
  )
```

```{r survival, fig.cap=" **Kaplan-Meier survival plot of low vs high group indicate a trend associating inflammatory status with survival prognostic.** Horizontal and vertical axes represent survival times and rates, respectively. Red and blue curves are samples with risk score higher and lower than the median value, respectively. Plus signs indicate censored values. Depicted P-values were obtained by the logrank test."}
suppressWarnings(print(ggsurv))
```

### Similarity of inflammatory signatures

```{r venn, out.width="100%", fig.cap = "Venn diagram comparing three inflammatory signatures."}
knitr::include_graphics("../04_figures/ggplot/Venn_estimate_vs_hallmark_inflammatory_response.png")
```

## Biological mechanisms underlying the inflammatory groups

### Differential Gene Expression Analysis

```{r load deseq2, include=FALSE}

librarian::shelf(
  tidyverse,
  magrittr,
  DESeq2,
  data.table,
  EnhancedVolcano,
  glue,
  ggpubr,
  ggVennDiagram,
  RSQLite,
  snakecase,
  vroom
)
```

```{r generate_raw_count, cache=TRUE, include=FALSE}
# 2. Generate raw data ONCE -----------------------------------------------
generate_protein_count_mat <- function(path, pattern) {
  files <- list.files(path, pattern, full.names = TRUE, recursive = TRUE, include.dirs = TRUE)
  mat <- as.data.frame(do.call(cbind, lapply(files, function(x) fread(x, stringsAsFactors = FALSE))))
  mat <- mat[-c(1:4), ]
  gene_type <- as.character(mat[, 3])
  rownames(mat) <- mat[, 1]
  mat <- as.data.frame(mat[, seq(4, ncol(mat), 9)])
  mat$gene_type <- gene_type
  mat <- subset(mat, mat$gene_type == "protein_coding")
  mat <- mat[, -c(ncol(mat))]
  return(mat)
}

protein_counts <- generate_protein_count_mat("02_data/GDC/GDC_data/", "\\.rna_seq.augmented_star_gene_counts.tsv$")


# Following step done with protein counts only
file_names <-
  list.files(
    "02_data/GDC/GDC_data/",
    "\\.rna_seq.augmented_star_gene_counts.tsv$",
    full.names = FALSE,
    recursive = TRUE,
    include.dirs = FALSE
  ) %>% sub(".*/", "", .)

samplesheet <-
  read.table(
    "02_data/GDC/GDC_metadata/gdc_sample_sheet.2022-04-29.tsv",
    header = T,
    sep = "\t"
  ) %>%
  .[match(file_names, .$File.Name), ] %>%
  mutate(
    "sample" =
      map_chr(
        Case.ID,
        ~ str_replace(., pattern = "TARGET-40-", replacement = "")
      ),
    .before = 1
  )

protein_counts %<>% set_colnames(samplesheet$sample)
# Read metadata
metadata <-
  readxl::read_xlsx("02_data/metadata/TARGET_OS_ClinicalData_Validation_20211108.xlsx") %>%
  set_names(snakecase::to_snake_case(colnames(.))) %>%
  mutate(
    "sample" = map_chr(
      target_usi,
      ~ str_replace(., pattern = "TARGET-40-", replacement = "")
    ),
    .before = 1
  ) %>%
  select(
    sample,
    age_at_diagnosis_in_days,
    overall_survival_time_in_days,
    time_to_death_in_days,
    time_to_first_relapse_in_days,
    vital_status
  )
# column_to_rownames("sample")

# Drop metadata samples that aren't in the 88 samples in GDC data
metadata %>% filter(sample %in% samplesheet)

# Do we really have 0 samples matching ?


head(fread("02_data/GDC/GDC_data/00411dbf-7487-46ff-b26a-85761719779e/c9372691-13e4-49a3-999c-ca21f54ad988.rna_seq.augmented_star_gene_counts.tsv"))
# We can obtain both raw counts and TPM / FPKM from TARGET-OS data



# Transform the gene_id to gene_name
count_data <- list.files(path = "02_data/GDC/GDC_data/", recursive = TRUE, full.names = TRUE)[1] %>%
  data.table::fread() %>% # data.table::fread works unlike readr::read_tsv here
  .[-c(1:4), ] %>%
  select(gene_id, gene_name) %>%
  right_join(rownames_to_column(protein_counts, "gene_id"))

# Duplicate genes exist in gene_name, we concatenate them so that we don't lose
# information
duplicate_gene <- count_data %>%
  group_by(gene_name) %>%
  filter(n() > 1) %>%
  unite(gene_name, gene_name, gene_id, sep = "-")

# Remove duplicate rows and add the concatenated rows back
full_data <- count_data %>%
  group_by(gene_name) %>%
  filter(!n() > 1) %>%
  bind_rows(duplicate_gene) %>%
  select(-gene_id) %>%
  column_to_rownames("gene_name")

# Remove empty columns with no expression
no_expression <- full_data %>%
  t() %>%
  as.data.frame() %>%
  select(where(~ sum(.) == 0))
glue("{length(no_expression)} genes were found with 0 expression ")
full_data %<>% t() %>%
  as.data.frame() %>%
  select(where(~ sum(.) != 0)) %>%
  t() %>%
  as.data.frame()

raw_data_path <- "03_results/DESeq2_raw_protein_data.tsv"
full_data %>%
  rownames_to_column("gene") %>%
  write_tsv(raw_data_path)
```

```{r deseq2, cache=TRUE, dependson="generate_raw_count", include=FALSE}

raw_data_path <- "03_results/DESeq2_raw_protein_data.tsv"
full_data <- read_tsv(raw_data_path) %>% column_to_rownames("gene")
clinical <- read_tsv("02_data/GDC/GDC_clinical_data/clinical.tsv") %>%
  mutate(
    "sample" =
      map_chr(
        case_submitter_id,
        ~ str_replace(., pattern = "TARGET-40-", replacement = "")
      ),
    .before = 1
  )

inflammatory_group_clinical <- read_tsv("03_results/hallmark_mean_groups.tsv") %>%
  right_join(clinical) %>%
  mutate(group_mean = as.factor(group_mean)) %>%
  mutate(vital_status = as.factor(vital_status))


dds <-
  DESeqDataSetFromMatrix(full_data,
    colData = inflammatory_group_clinical,
    design = ~ group_mean + vital_status,
  )
dds$vital_status <- relevel(dds$vital_status, ref = "Dead")
dds$group_mean <- relevel(dds$group_mean, ref = "Low")
dds <- DESeq(dds)


# DESeq2 results
DESeq2_vital_status <-
  DESeq2::results(dds, contrast = c("vital_status", "Dead", "Alive"))
DESeq2_group_mean_Low_vs_Medium <-
  DESeq2::results(dds, contrast = c("group_mean", "Low", "Medium"))
DESeq2_group_mean_Medium_vs_High <-
  DESeq2::results(dds, contrast = c("group_mean", "Medium", "High"))
DESeq2_group_mean_Low_vs_High <-
  DESeq2::results(dds, contrast = c("group_mean", "Low", "High"))

DESeq2_vital_status_df <- as.data.frame(DESeq2_vital_status)


# Create a list with df_name inside to input into get_DEG_genes
DESeq2_inflammation <- list(
  DESeq2_group_mean_Low_vs_Medium_df = as.data.frame(DESeq2_group_mean_Low_vs_Medium),
  DESeq2_group_mean_Medium_vs_High_df = as.data.frame(DESeq2_group_mean_Medium_vs_High),
  DESeq2_group_mean_Low_vs_High_df = as.data.frame(DESeq2_group_mean_Low_vs_High)
) %>%
  Map(cbind, ., df_name = names(.)) %>%
  map(drop_na)

DESeq2_inflammation %>%
  map_dfr(~ rownames_to_column(.x, "gene")) %>%
  write_tsv("../TargetOS-Osteosarcoma/03_results/DESeq2_genes/DEG_results/DESeq2_inflammation_TARGET-OS.tsv")


# Function to split results into up and downregulated genes
get_DEG_genes <-
  function(data,
           condition = NULL,
           write = TRUE,
           return_all_DEG = FALSE,
           padj_cutoff = 0.05,
           lfc_cutoff = 1,
           use_list = FALSE) {

    # Use use_list == TRUE if using inside purrr::map or lapply
    df_name <- deparse(substitute(data))
    if (use_list == TRUE) {
      df_name <- distinct(data, df_name) %>% pull()
    }


    # Failsafe to ensure "tidy" format, rownames are assumed to be genes
    # This is useful when binding gene in a single df, where genes are duplicates
    # This ensures the rest of the function works in tidy and non tidy df
    if (tibble::has_rownames(data) == TRUE) {
      data %<>% rownames_to_column("gene")
    }


    file_path <- "03_results/DESeq2_genes/"
    dir.create(file_path, showWarnings = FALSE)
    if (!is.null(condition)) {
      condition_name <- condition
    } else {
      condition_name <-
        str_extract(df_name, "[[:alpha:]]*_vs_[[:alpha:]]*")
    }


    # log2(1) = 2 in FoldChange
    # FDR with BH by default in DESeq2
    up_reg <- filter(data, padj <= padj_cutoff & log2FoldChange >= lfc_cutoff) %>%
      mutate("condition" = condition_name)
    down_reg <- filter(data, padj <= padj_cutoff & log2FoldChange <= -lfc_cutoff) %>%
      mutate("condition" = condition_name)


    if (write == TRUE) {
      up_reg %>%
        select(gene) %>%
        write_tsv(
          glue(
            "{file_path}upregulated_genes-{df_name}.tsv"
          ),
          col_names = FALSE
        )
      down_reg %>%
        select(gene) %>%
        write_tsv(
          glue(
            "{file_path}downregulated_genes-{df_name}.tsv"
          ),
          col_names = FALSE
        )

      DEG_gene <- bind_rows(up_reg, down_reg)

      DEG_gene %>%
        pull(gene) %>%
        tibble() %>%
        write_tsv(glue("{file_path}DEG_genes-{df_name}.tsv"),
          col_names = FALSE
        )
    }

    cat(
      glue("Gene list obtained for {df_name}.
           There is {nrow(up_reg)} upregulated genes.
           There is {nrow(down_reg)} downregulated genes.
           Gene list saved in {file_path}.\n

           ")
    )
    if (return_all_DEG == TRUE) {
      return(DEG_gene)
    }

    list(up_regulated = up_reg, down_regulated = down_reg) %>%
      return()
  }

# Return a list with separated up and downregulated genes and write down genes
# for ORA (Over Representation Analysis)
DESeq2_inflammation_DEG <- DESeq2_inflammation %>%
  purrr::map(get_DEG_genes, use_list = TRUE)



## Plot volcano plot ======================================================

plot_volcano <- function(data, use_list = TRUE, tidy = FALSE) {
  df_name <- deparse(substitute(data))
  if (use_list == TRUE) {
    df_name <- distinct(data, df_name) %>% pull()
  }

  if (tidy == TRUE) {
    label_name <- dplyr::pull(data, 1)
  } else {
    label_name <- row.names(data)
  }

  message(glue("Plotting {df_name}"))
  condition_name <-
    str_extract(df_name, "[[:alpha:]]*_vs_[[:alpha:]]*")

  file_dir <- "04_figures/DESeq2_results/"

  volcano <- EnhancedVolcano(
    data,
    lab = label_name,
    x = "log2FoldChange",
    y = "pvalue",
    subtitle = "",
    pointSize = 2,
    pCutoff = 0.05,
    pCutoffCol = "padj",
    FCcutoff = 1,
    title = glue("{to_any_case(condition_name, case = 'title')}"),
    drawConnectors = TRUE,
    widthConnectors = 1.0,
    colConnectors = "black",
    arrowheads = FALSE,
    gridlines.major = FALSE,
    gridlines.minor = FALSE,
    boxedLabels = TRUE,
  )
  volcano_path <- glue("{file_dir}volcano_plot-{condition_name}.png")
  ggsave(volcano_path,
    height = 10,
    width = 10,
    dpi = "retina"
  )
  print(glue("Volcano plot saved in {volcano_path}"))

  return(volcano)
}

volcano_list <- map(DESeq2_inflammation, plot_volcano)


volc_plot <- ggarrange(
  plotlist = volcano_list,
  ncol = 3,
  nrow = 1,
  align = "hv",
  labels = c("A", "B", "C"),
  common.legend = TRUE
)

volc_lh <- ggarrange(volcano_list[[3]])


ggsave("04_figures/DESeq2_results/volcano_plot-inflammatory_group.png",
  height = 10,
  width = 18
)
```

```{r volc-plot, echo=FALSE, fig.cap="**Volcano plot of the differentially expressed genes in Low vs High condition. Negative Log~2~ of fold change represent a gene that is more differentially expressed Low condition, and _vice versa_. ** P $\\leq$ 0.05 and Log~2~ fold change $\\leq$ 1 or $\\geq$ 1 was used for cutoff.", fig.height=10, dependson="deseq2"}

suppressWarnings(print(volc_lh))
```

A differential gene expression analysis was performed in Low versus High
group.

### Gene Set Enrichment Analysis (GSEA)

```{r gsea, cache=TRUE, include=FALSE}


# 1. Setup ----------------------------------------------------------------

librarian::shelf(
  tidyverse,
  glue,
  magrittr,
  msigdbr,
  fgsea,
  clusterProfiler,
  enrichplot,
  snakecase,
  vroom
)


# Read data
data <-
  vroom("03_results/DESeq2_genes/DEG_results/DESeq2_inflammation_TARGET-OS.tsv")
data_low_vs_high <-
  data %>% filter(df_name == "DESeq2_group_mean_Low_vs_High_df") # %>%
# filter(gene %in% hallmark_inflammatory)
# Note that ICAM4 doesn't appear thus we have a gene list of 199 genes
gene_list_inflam <- data_low_vs_high %>%
  drop_na(log2FoldChange) %>%
  select(gene, log2FoldChange)

# The log2FC of all genes is sorted from high to low, in order to input a pre-ranked in a way that upregulated genes have lower ranks than downregulated genes.
gene_list_inflam %<>%
  pull(log2FoldChange) %>%
  sort(decreasing = TRUE) %>%
  set_names(gene_list_inflam$gene)


gene_list_diap <- vroom("03_results/DESeq2_genes/DEG_results/DESeq2_diapedesis_TARGET-OS.tsv") %>%
  dplyr::select(gene, log2FoldChange)
gene_list_diap %<>%
  pull(log2FoldChange) %>%
  sort(decreasing = TRUE) %>%
  set_names(gene_list_diap$gene)



# 2. msigdbr --------------------------------------------------------------


# Get pathway from source "01_script/get_msigdb_signature.R"
msigdb_files <-
  list.files("02_data/msigdb_signature/", full.names = TRUE)
all_signatures <- msigdb_files %>%
  map(vroom) %>%
  set_names(basename(tools::file_path_sans_ext(msigdb_files)))


# Make GSEA and GSEA Table
make_gsea_clusterProfiler <-
  function(gene_list,
           msigdb_signature,
           dir_save = "04_figures/GSEA/clusterProfiler/",
           get_gsea_plot = FALSE) {
    # Traditional running enrichment score

    msigdb_signature_df <- bind_rows(msigdb_signature)

    set.seed(123)
    gsea_msig <-
      GSEA(
        gene_list,
        TERM2GENE = msigdb_signature_df,
        minGSSize = 1,
        maxGSSize = 10000,
        verbose = TRUE,
        seed = TRUE,
        by = "fgsea",
        pvalueCutoff = 1
        # adjusted pvalue cutoff to allow every signatures in @result tab
      )

    if (get_gsea_plot == TRUE) {
      # Single GSEA plot for each gene set
      gsea_msig@result[["ID"]] %>%
        map2(seq_along(.), ~ {
          gseaplot2(
            gsea_msig,
            geneSetID = .y,
            title = glue("{.x}"),
            pvalue_table = TRUE
          )
          dir.create(dir_save, showWarnings = FALSE)
          ggsave(glue("{dir_save}GSEA-{.x}.png"), width = 10)
          print(glue("Single GSEA plot saved for {.x}"))
        })
    }
    # Combined GSEA plot for each separate element in msigdb_signature list
    iwalk(msigdb_signature, ~ {
      signature_group <- distinct(., gs_name) %>% pull()
      signature_index_id <- which(gsea_msig@result[["ID"]] %in% signature_group)
      gseaplot2(
        gsea_msig,
        geneSetID = signature_index_id,
        title = glue("{.y}"),
        pvalue_table = TRUE
      )

      dir.create(glue("{dir_save}combined_GSEA/"), showWarnings = FALSE)
      ggsave(glue("{dir_save}combined_GSEA/GSEA_combined-{.y}.png"),
        width = 12
      )
      print(glue("Combined GSEA plot saved for {.y}"))
    })

    # Ridgeplot
    ridgeplot(gsea_msig, orderBy = "NES", decreasing = TRUE)
    dir.create(glue("{dir_save}ridgeplot/"), showWarnings = FALSE)
    ggsave(glue("{dir_save}ridgeplot/GSEA-ridgeplot.png"))
    print(glue("Ridge plot"))

    # Make p significant table for easy visualization
    gsea_msig_sign <- gsea_msig@result %>%
      rownames_to_column("Pathway") %>%
      mutate(
        p.sign = case_when(
          p.adjust <= 0.001 ~ "***",
          p.adjust <= 0.01 ~ "**",
          p.adjust <= 0.1 ~ "*",
          TRUE ~ "ns"
        ),
        Pathway = to_title_case(Pathway)
      ) %>%
      dplyr::select(Pathway,
        "Set Size" = setSize,
        NES,
        p.adjust,
        qvalues,
        p.sign
      )
    dir.create(glue("{dir_save}GSEA_table/"), showWarnings = FALSE)

    # Do a separate table for each sublist with p.sign
    iwalk(msigdb_signature, ~ {
      signature_group <- distinct(.x, gs_name) %>%
        pull() %>%
        to_title_case()
      html_file <- glue("{dir_save}GSEA_table/GSEA_table-{.y}.html")
      gsea_msig_sign %>%
        filter(Pathway %in% signature_group) %>%
        kableExtra::kbl("html") %>%
        kableExtra::kable_styling() %>%
        kableExtra::save_kable(html_file)

      # Instead of using save_kable to png directly, which doesn't work, we use a
      # workaround by saving html first and using webshot to save png, which is what
      # the function is supposed to do automatically anyway
      webshot::webshot(
        html_file,
        glue("{dir_save}GSEA_table/GSEA_table_sign-{.y}.png")
      )
      print(glue("GSEA Table saved for {.y} in {dir_save}GSEA_table/."))
    })
    return(gsea_msig_sign)
  }



gsea_df <- make_gsea_clusterProfiler(gene_list_inflam, all_signatures,
  dir_save = "04_figures/GSEA/inflammation/clusterProfiler/"
)
```

GSEA was performed on `r nrow(gsea_df)` selected signatures from MSigDB,
based on the theme of osteosarcoma, angiogenesis, neutrophils,
migration, hypoxia and inflammation. Only significant pathways are
reported in the table. Certain pathways are not significant but
relevant, such as "Gobp Positive Regulation of Vascular Associated
Smooth Muscle Cell Proliferation" (P = 0.13), "Gobp Positive Regulation
of Inflammatory Response", and all other pathways concerning dendritic,
lymphocyte, monocyte, macrophage chemotaxis and migration.

Interestingly, there is no found significant pathway relating to
positive regulation of inflammation, but there are significant pathways
relating to negative regulation of inflammation, indicating that in the
high group, there is negative regulation of inflammation. Similarly, the
only signature with a negative enrichment score is "Gobp Positive
Regulation of Neutrophil Activation". It is also notable that the
signature *Hp Osteosarcoma* in GSEA is not significantly different (*P =
0.38*).

```{r gsea-table, dependson="gsea", fig.cap="GSEA table"}
gsea_df %>%
  filter(p.adjust <= 0.10) %>%
  dplyr::select(-qvalues) %>%
  kableExtra::kbl(
    format = "latex",
    caption = glue("Results of GSEA by clusterProfiler, pre-ranked by descending order of log2 of fold change for genes differentially expressed in low vs high condition. Genes at the top of the list are thus differentially expressed in the high group, and vice versa. Only significant pathways are shown, out of {nrow(gsea_df)} selected pathways. P.adjust ≤ 0.10 is considered significant."),
    digits = 2,
    booktabs = TRUE,
    # longtable = TRUE
  )
```

```{r write_packages}
knitr::write_bib(c(.packages()), "../R-Markdown-Report/bibliography/packages.bib")
```
